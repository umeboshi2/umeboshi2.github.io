{"content": "# Application Development Environment\n\n## Development Environments\n\nVagrant is the development environment of choice, since it\nrequires the least amount of changes to the operating system.\nAll that is needed is virtualbox and the vagrant application.  In\nthe future, docker will be used to contain the development\nenvironment.  Using vagrant allows for better server side development,\nwhere the developer can configure services that won't interfere\nwith the developer's system.  The environment is configured\nusing [salt](http://www.saltstack.com).\n\nAn alternative to using vagrant, which is the alternative used\non my netbook of limited resources, is to use schroot to\ncontain the development enviroment in a chroot.  This can also\nbe configured with salt, and a script exists in the scripts/\ndirectory to achieve this.\n\nOf course, development can be done natively in the operating system,\nif desired.\n\n## node.js\n\nA [node.js](http://nodejs.org) environment is used to develop and\nbuild the applications.  [Grunt](http://gruntjs.com/) is used to\nbuild and optimize the static resources for the client application.\nThe Gruntfile is written in coffeescript.  [bower](http://bower.io)\nis also used in the node environment to install the upstream\nstatic resources needed by the application.\n\n## CoffeeScript\n\n[CoffeeScript](http://coffeescript.org/) is used as the language \nof choice for developing applications with \n[Backbone.Marionette](http://marionettejs.com/).  When I began \nnoticing the necessity of learning javascript to achieve a \nbetter application platform, I decided to use coffeescript for \na large number of reasons.  I had already been hesitant to use \njavascript, so being a python developer, I started by looking \nat javascript alternatives that would allow me to perform \nclient side development without a heavy investment into learning \nanother language.  I came across some projects that took a \npython file and compiled it into javascript, but this turned \nout to be a greater hassle than expected.\n\nI happened to chance upon coffee script one day and decided to \ntry it out.  While I was initially using it to provide a \nwhitespace environment for creating javascript, I found that\nthe coffeescript language provides a lot of valuable assistance to a \nperson learning to program in a javascript environment.  Not \nonly does the syntactic sugar provide for cleaner and more \nreadable code, it also provides readable reliability when performing \nsome common actions that are a bit tricky to do correctly in \njavascript, such as testing for *undefined*.  Even more valuable \nis the default behaviour to wrap the code in an anonymous function,\nand also forcing every variable to be declared locally on first chance \nin that anonymous function, making it very difficult to pollute \nthe global namespace accidentally.\n\n## Backbone.Marionette\n\nMarionette is the main application framework.  Marionette makes \nit easier to organize application code into smaller more \nmanageable module.  It uses a communication mechanism to \ndecouple the components of the application, making it easier to \ndevelop each part separately.\n\n### Application Model\n\nAn application model looks like this:\n\n- AppModel\n  - brand:\n\t- name: 'App Name'\n\t- url: '#'\n  - apps: \n\t- { appname:'', name:'', url:''}\n  - appregions\n  - approutes\n\n\n### Common Modules\n\nCommon modules exist in the common/ directory.\n\n#### appregions\n\nThis module contains the default appregion objects which can\nbe passed to the addRegions method of the\n[application](http://marionettejs.com/docs/marionette.application.html)\nobject.  There is a basic object for a static application, as well\nas one for applications that have authenticated users.\n\nThis module also has a function to prepare the application.  It adds\nthe [regions](http://marionettejs.com/docs/marionette.region.html)\ndescribed in the appregions property of the appmodel object.  It adds\ndefault show and empty view handlers on the main message bus for each\nregion described in the appregions object, in the\nform appregion:{region}:{action}.  It also adds the routes described\nin the approutes property of the appmodel.\n\n#### approuters\n\nThis is just a simple\n[AppRouter](http://marionettejs.com/docs/marionette.approuter.html)\nthat updates the navbar when the child app changes.\n\n### controllers\n\nThere is a simple SideBarController that doesn't do very much but help\nmaintain a \"side bar\", which is a common feature of many controllers.\nThis module exists to provide common functionality to controllers\nwhen the need arises.\n\n### mainpage\n\nThis module needs to be fixed, as it is too constrictive concerning\nthe views and layout that are used on all the pages.  However, this\nmodule does provide a common *initialize_page* function that nests\nthe rendering of the navbar view upon completion of the rendering\nof the main layout.  The main layout contains most of the elements\nof the default appregions.  The main layout is currently a bootstrap\ntwo column layout with a fixed navbar.  This function needs to be\nupdated to handle different layouts and nested views.  This function\nis contained in a message bus wrapper with the signal *mainpage:init*.\n\n\nThere is also a function that sets a handler for when the\nnavbar is displayed to add a user menu view to the navbar.\nThis helps minimize the amount of code that distinguishes an\napplication that requires authenticated users, and static apps\nthat have no such requirements.\n\nEvery function exported in this module requires the MainBus\nto be passed as a parameter to set handlers for the functionality.\n\n### mainviews\n\nThere are four basic views defined here.  The main page layout,\nas well as the navbar view are defined here.  There is also\na login view and a user menu view.  These views do nothing\nbut use specific templates in *common/templates*.\n\n### templates\n\nThere are common templates here for the four views described\nabove. There is also a common template to create a side bar\nwith buttons, as well as a function to create a label and\ninput for a bootstrap form.\n\n### models\n\nThere is a model here to contain the current authenticated\nuser of the application.  There must be a url on the\nserver that returns a \"current user\" object to fill the\nmodel.\n\n\n### Application Skeleton\n\nThe application skeleton was inspired by this github\n[project](https://github.com/t2k/backbone.marionette-RequireJS),\nwhich provides some simple boilerplate code to start\na single page application using marionette, coffeescript, and\nrequirejs.  It also taught me to use bower to manage the\ncomponents and their dependencies.\n\n- **main (main-local)**\n  This is where the requirejs config is located.  This file is \n  responsible for importing the application module and starting\n  the application.\n- **application**\n  - This module is responsible for the initial setup of the\n\t[application](http://marionettejs.com/docs/marionette.application.html).\n  - This module sets the\n\t[Regions](http://marionettejs.com/docs/marionette.region.html)\n\tfor the main page.\n  - It starts the\n\t[AppRouters](http://marionettejs.com/docs/marionette.approuter.html)\n\tof all the sub applications.\n  - If logins are used, this module sets the handler for the user info\n\tand starts the app after fetching the user info.\n- **models** and **collections**\n  These provide access to\n  [models](http://backbonejs.org/#Model) and\n  [collections](http://backbonejs.org/#Collection) that are \n  global to the application, such as \"current user info\" for\n  the logged in user.\n- **msgbus**\n  This is the global\n  [message bus]( https://github.com/marionettejs/backbone.wreqr)\n  (MainBus) that allows communication \n  between the main application and the sub apps.\n\n### Child Application Skeleton\n\nThe child application exists *logically* in a subdirectory of\nthe main application root.  The structure of the child application,\nalong with the use of a separate message bus for each child application,\nprovides the ability to use the same child application in multiple\nmain apps, if needed.  If the child application is not in the subdirectory\nof the main application, the path needs to be configured in requirejs\nconfig object.\n\n- **main**\n  - The main module is responsible creating the router that maps\n\tthe routes to methods on the controller.\n- **models** and **collections**\n  - These modules provide the models and collections specific to\n\tthe child application.\n- **msgbus**\n  - This is the child specific message bus (AppBus).  The channel\n\tit defines *must* have a unique name.\n- **controller**\n  - The [controller](http://marionettejs.com/docs/marionette.controller.html)\n\tbasically handles the route requests by managing the views\n\tfor those routes.\n- **views**\n  These are the\n  [views](http://marionettejs.com/docs/marionette.region.html)\n  that will be used in this child application.\n- **templates**\n  These are the teacup templates for the views in this child application.\n\n### Frontdoor Application\n\nThe frontdoor application is the default child application.  One\nchild application must exist to perform the function of an \"index.html\"\npage.  This can be considered the root path of the main application.\nThe frontdoor application can be required last in the application module\nand interact with the functionality of those child applications, such as\naccessing models, collections, templates, and views of those child\napplications with the controller of the frontdoor application.\n\n", "id": "application-development-environment"}